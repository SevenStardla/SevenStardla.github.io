---
title: "[Baekjoon 5585] 거스름돈 - Greedy Algorithm"
date: 2025-08-14 20:00:00 +09:00
categories: [Algorithm, Baekjoon]
tags: [greedy, python, baekjoon]
math: false
toc: true
pin: false
image:
  path: /assets/postImage/money-2180330_1280.png
  alt: Baekjoon 5585 거스름돈
---

## **1. 그리디 알고리즘(Greedy Algorithm) 개념**

그리디 알고리즘은 **현재 시점에서 가장 좋아 보이는 선택**을 반복하여 최종 해답에 도달하는 알고리즘 설계 기법입니다.  
즉, **국소적으로 최적**이라고 판단되는 선택이 전체적으로도 최적이라는 가정 하에 동작합니다.

- 특징
  - 매 단계에서 가장 큰(또는 작은) 값을 우선 선택
  - 항상 최적해를 보장하지는 않음 → **문제 조건이 이를 보장할 때 사용**
- 예시
  - 동전 거스름돈 문제 (동전 단위가 큰 단위의 배수일 때)
  - 회의실 배정 문제
  - 최소 스패닝 트리(Prim, Kruskal)

---

## **2. 문제 설명**

타로는 자주 JOI잡화점에서 물건을 삽니다.  
JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있습니다.  
언제나 거스름돈 개수가 가장 적게 되도록 줍니다.  

타로가 1000엔 지폐로 물건을 사고, 거스름돈을 받을 때 포함된 **잔돈의 개수**를 구하는 프로그램을 작성하세요.

- **입력**
  - 타로가 지불할 돈 N (1 이상 1000 미만의 정수) 1개
- **출력**
  - 거스름돈에 포함된 동전의 개수

---

## **3. 예제**

| 입력 | 출력 |
|------|------|
| 380  | 4    |

---

## **4. 접근 방법**

1. 총 거스름돈 = 1000 - 지불 금액
2. 동전 단위를 **내림차순**으로 준비
3. 큰 단위부터 가능한 만큼 거슬러 줌
4. 남은 금액이 0이 될 때까지 반복

이 문제의 동전 단위는 **큰 단위가 작은 단위의 배수**이므로, 그리디 알고리즘이 항상 최적해를 보장합니다.

---

## **5. 코드 구현 (Python)**

```python
G = 0
a = [500, 100, 50, 10, 5, 1]  # 동전 단위
C = 1000
N = int(input())
J = C - N  # 거스름돈

for i in a:
    if i <= J:
        temp = J // i
        G += temp
        J %= i
    if J == 0:
        break

print(G)
```

---

## **6. 동작 예시**

- 입력: `380`
- 거스름돈: `1000 - 380 = 620`
- 과정:
  - 500엔 1개 → 남은 120엔
  - 100엔 1개 → 남은 20엔
  - 10엔 2개 → 남은 0엔
- 총 개수: **4**

---

## **7. 복잡도 분석**

- 동전 개수 = 고정된 6개 → **O(1)**
- 매우 빠른 시간 안에 결과 도출 가능

---

## **8. 정리**
- 동전 단위가 큰 단위의 배수일 때, **그리디 알고리즘**으로 항상 최소 개수를 구할 수 있음
- 이 문제는 전형적인 **동전 거스름돈 문제**로, 알고리즘 학습 초기에 다루기 좋음
